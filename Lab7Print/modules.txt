module DE1_SoC(CLOCK_50, KEY, SW, LEDR, HEX0, HEX5);
	input CLOCK_50;
	input [9:0]SW;
	input [0:0] KEY;
	output reg [6:0] HEX0, HEX5;
	output [9:1] LEDR;

	wire [31:0] clk;
	parameter whichClock = 15;

	wire Reset, L2, R2, win1, win2;

	assign Reset = SW[9];
	wire [8:0] Q;
	wire [9:0] E;
	
	assign L2 = E[9];
	
	clock_divider divider (CLOCK_50, clk);
	
	addMod a(SW[8:0], Q, E);
	victory computer(clk[whichClock], Reset, win2, HEX5);
	victory human(clk[whichClock], Reset, win1, HEX0);
	
	userInput right (.Clock(clk[whichClock]), .Reset, .inButton(~KEY[0]), .outButton(R2));
		
	leftMost leftmost (.Clock(clk[whichClock]), .Reset, .L(L2), .R(R2), .NR(LEDR[8]), .lightOn(LEDR[9]), .winner(win2));
	centerLight center (.Clock(clk[whichClock]), .Reset, .L(L2), .R(R2), .NL(LEDR[6]), .NR(LEDR[4]), .lightOn(LEDR[5]), .win1, .win2);
	rightMost rightmost (.Clock(clk[whichClock]), .Reset, .L(L2), .R(R2), .NL(LEDR[2]), .lightOn(LEDR[1]), .winner(win1));
	normalLight N_8 (.Clock(clk[whichClock]), .Reset, .L(L2), .R(R2), .NL(LEDR[9]), .NR(LEDR[7]), .lightOn(LEDR[8]));
	normalLight N_7 (.Clock(clk[whichClock]), .Reset, .L(L2), .R(R2), .NL(LEDR[8]), .NR(LEDR[6]), .lightOn(LEDR[7]));
	normalLight N_6 (.Clock(clk[whichClock]), .Reset, .L(L2), .R(R2), .NL(LEDR[7]), .NR(LEDR[5]), .lightOn(LEDR[6]));
	normalLight N_4 (.Clock(clk[whichClock]), .Reset, .L(L2), .R(R2), .NL(LEDR[5]), .NR(LEDR[3]), .lightOn(LEDR[4]));
	normalLight N_3 (.Clock(clk[whichClock]), .Reset, .L(L2), .R(R2), .NL(LEDR[4]), .NR(LEDR[2]), .lightOn(LEDR[3]));
	normalLight N_2 (.Clock(clk[whichClock]), .Reset, .L(L2), .R(R2), .NL(LEDR[3]), .NR(LEDR[1]), .lightOn(LEDR[2]));
	
	LFSR submod (clk[whichClock], Reset, Q);
	
endmodule

module clock_divider (Clock, divided_clocks); 
 input Clock; 
 output [31:0] divided_clocks; 
 reg [31:0] divided_clocks; 
 
 initial 
 divided_clocks = 0; 
 
 always @(posedge Clock) 
 divided_clocks = divided_clocks + 1; 
endmodule 


module centerLight (Clock, Reset, L, R, NL, NR, lightOn, win1, win2); 
 input Clock, Reset, win1, win2, L, R, NL, NR;
 output lightOn;
 reg PS;
 reg NS;

 parameter on = 1'b0, off = 1'b1;
 
 always @(*)
	case(PS)
		on: if (L ^ R) NS = off;
			 else NS = on;
			 
		off: if ((L & ~R & NR) | (~L & R & NL) | win1 | win2) NS = on;
			  else NS = off;
		default: NS = 1'bx;
	endcase
	
 always @(*)
	case(PS)
		on: lightOn = 1;
		off: lightOn = 0;
		default: lightOn = 1'bx;
	endcase
	
 // DFF
 always @(posedge Clock) 
	if (Reset) 
		PS <= on; 
	else 
		PS <= NS;
		
endmodule


module normalLight (Clock, Reset, L, R, NL, NR, lightOn); 
 input Clock, Reset;
 input L, R, NL, NR;
 output reg lightOn;
 reg PS;
 reg NS;
 parameter off = 1'b0, on = 1'b1;
   
 always @(*)
case (PS)
	off:
	if ((R & NL & ~L) |(L & NR & ~R)) NS = on;
	else NS = off;
	
	on:
	if (L ^ R) NS = off;
	else NS = on;
	
	default NS = 1'bx;
	endcase
	
always @(*)
case (PS)
	off: lightOn = 0;
	on: lightOn = 1;
	default lightOn = 1'bx;
	endcase
	

 // DFF
 always @(posedge Clock) 
	if (Reset) 
		PS <= off; 
	else 
		PS <= NS;
  
endmodule

module leftMost(Clock, Reset,L, R, NR, lightOn, winner);
input Clock, Reset, L, R, NR;
output reg lightOn; 
output reg winner;
reg [1:0] PS;
reg [1:0] NS;

parameter [1:0] off= 2'b00, on= 2'b01, win= 2'b10;

	always @(*)
		case(PS)
			off: if(L & NR) NS = on;
				  else NS = off;
				  
			on: if (R) NS = off;
				 else if (L) NS = win;
				 else NS = on;
				
			win: NS = off;
			default: NS =2'bxx;
		endcase
	
	always @(*)
		case(PS)
		on: begin
			 lightOn = 1;
			 winner = 0;
			 end
		off: begin
			  lightOn = 0;
			  winner = 0;
			  end
		win: begin
			  lightOn = 0;
			  winner = 1;
			  end
		default: lightOn =1'bx;
	endcase
	

 // DFF
 always @(posedge Clock) 
	if (Reset) 
		PS <= off; 
	else 
		PS <= NS;
			
endmodule


module rightMost(Clock, Reset,L, R, NL, lightOn, winner);
input Clock, Reset, L, R, NL;
output reg lightOn; 
output reg winner;
reg [1:0] PS;
reg [1:0] NS;

parameter [1:0] off= 2'b00, on= 2'b01, win= 2'b10;

	always @(*)
		case(PS)
			off: if(R & NL) NS = on;
				  else NS = off;
				 
			on: if (L) NS = off;
				 else if (R) NS = win;
				 else NS = on;
				 
			win: NS = off;
			default: NS =2'bxx;
		endcase
	
	always @(*)
		case(PS)
		off: begin
				lightOn = 0;
				winner = 0;
			  end
			  
		on: begin
				lightOn = 1;
				winner = 0;
			 end
			 
		win: begin
				lightOn = 0;
				winner = 1;
			  end
		default: lightOn =1'bx;
	endcase
	
 // DFF
 always @(posedge Clock) 
	if (Reset) 
		PS <= off; 
	else 
		PS <= NS;
		
endmodule


module userInput (Clock, Reset, inButton, outButton); 
 input Clock, Reset, inButton;
 output reg outButton;
 reg PS;
 reg NS;
 
 parameter off = 1'b0,  on= 1'b1;
 
 always @(*)
	case(PS)
		on: if (inButton) NS = on;
				else NS = off;
				
		off: if (inButton) NS = on;
			   else NS = off;
		default: NS = 1'bx;
	endcase
	
	always @(*)
		if (PS == on & NS == off) outButton = 1;
		else outButton = 0;
		
	
 // DFF
 always @(posedge Clock) 
	if (Reset) 
		PS <= off; 
	else 
		PS <= NS;
		
endmodule


module LFSR (Clock, Reset, Q);
input Clock, Reset;
output [9:1]Q;
wire P;

assign P = Q[5] ^~ Q[9];
FF one (Q[1], P, Reset, Clock);
FF two (Q[2], Q[1], Reset, Clock);
FF three (Q[3], Q[2], Reset, Clock);
FF four (Q[4], Q[3], Reset, Clock);
FF five (Q[5], Q[4], Reset, Clock);
FF six (Q[6], Q[5], Reset, Clock);
FF seven (Q[7], Q[6], Reset, Clock);
FF eight (Q[8], Q[7], Reset, Clock);
FF nine (Q[9], Q[8], Reset, Clock);

endmodule

module FF (Q, D, Reset, clk);
output Q;
input D, Reset, clk;
reg Q;
always @(posedge clk or posedge Reset)
if (Reset)
Q = 0;
else
Q = D;
endmodule


module adder (A, B, C, D, E);
input A,B,C;
output E,D;

assign D = ( A & B ) |  ( C & ( A | B ) );
assign E = (A^B)^C;
endmodule

module addMod (A, B, E, clk, Reset);
input [8:0] A,B;
input clk, Reset;
output [9:0] E;
wire [9:0]D;

assign E[9] = D[8];
adder a(A[0],B[0],0,D[0],E[0]);
adder b(A[1],B[1],D[0],D[1],E[1]);
adder c(A[2],B[2],D[1],D[2],E[2]);
adder d(A[3],B[3],D[2],D[3],E[3]);
adder e(A[4],B[4],D[3],D[4],E[4]);
adder f(A[5],B[5],D[4],D[5],E[5]);
adder g(A[6],B[6],D[5],D[6],E[6]);
adder h(A[7],B[7],D[6],D[7],E[7]);
adder i(A[8],B[8],D[7],D[8],E[8]);

endmodule


module victory (Clock, Reset, vict, out);
input Clock, Reset, vict;
output reg [6:0] out;
reg [2:0] PS;
reg [2:0] NS;

parameter [2:0] O=3'b000, ONE=3'b001, TWO=3'b010, THREE=3'b011, FOUR=3'b100, FIVE=3'b101, SIX=3'b110, SEVEN=3'b111;


always@(*) begin
if (vict) begin
case (PS)
O: NS = ONE;
ONE: NS = TWO;
TWO: NS = THREE;
THREE: NS = FOUR;
FOUR: NS = FIVE;
FIVE: NS = SIX;
SIX: NS = SEVEN;
SEVEN: NS= SEVEN;
default: NS = 3'bxxx;
endcase
end
else begin
NS = PS;
end
end

always @ (*)
case (PS)
O: out = ~7'b0111111;
ONE: out = ~7'b0000110;
TWO: out = ~7'b1011011;
THREE: out = ~7'b1001111;
FOUR: out = ~7'b1100110;
FIVE: out = ~7'b1101101;
SIX: out = ~7'b1111101;
SEVEN: out = ~7'b0000111;
default: out = 7'bxxxxxxx;
endcase

 // DFF
 always @(posedge Clock) 
	if (Reset) 
		PS <= 0; 
	else 
		PS <= NS;
endmodule

